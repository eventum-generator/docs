---
title: Getting started
description: Learn how Eventum works and generate your first events in minutes.
---

<div className="not-prose my-6 rounded-2xl border border-fd-border bg-linear-to-br from-fd-card via-fd-card to-[#8282ef]/10 p-8 text-center">
  <img src="/logo.svg" alt="Eventum" className="h-16 w-auto mx-auto mb-4" />
  <div className="text-2xl font-semibold mb-2">Welcome to Eventum</div>
  <div className="text-fd-muted-foreground max-w-2xl mx-auto">
    A data generation platform that produces synthetic events and delivers them
    anywhere â€” in real time or in batch. Describe <strong>what</strong> your data looks like
    and <strong>when</strong> it should appear, Eventum takes care of the rest.
  </div>
</div>

---

## âš¡ Why Eventum

Building and testing data-driven systems usually means waiting for real data to accumulate or writing throwaway scripts. Eventum gives you a declarative way to generate realistic data on demand.

<div className="not-prose grid grid-cols-1 sm:grid-cols-2 gap-3 my-6">
  <div className="rounded-xl border border-fd-border bg-fd-card p-4">
    <div className="text-lg mb-1">ğŸ­ Realistic content</div>
    <div className="text-sm text-fd-muted-foreground">Templates powered by Faker and Mimesis produce believable names, IPs, timestamps, and domain-specific values.</div>
  </div>
  <div className="rounded-xl border border-fd-border bg-fd-card p-4">
    <div className="text-lg mb-1">ğŸ• Precise timing</div>
    <div className="text-sm text-fd-muted-foreground">Cron schedules, fixed intervals, uniform ranges, or statistical patterns that mimic real-world traffic.</div>
  </div>
  <div className="rounded-xl border border-fd-border bg-fd-card p-4">
    <div className="text-lg mb-1">ğŸ“¡ Multiple destinations</div>
    <div className="text-sm text-fd-muted-foreground">stdout, files, ClickHouse, OpenSearch, or any HTTP endpoint â€” all at the same time.</div>
  </div>
  <div className="rounded-xl border border-fd-border bg-fd-card p-4">
    <div className="text-lg mb-1">ğŸ”€ Live and batch modes</div>
    <div className="text-sm text-fd-muted-foreground">Stream events at their actual timestamps, or generate an entire dataset as fast as possible.</div>
  </div>
</div>

---

## ğŸ”§ How it works

Every generator runs a three-stage pipeline. You describe each stage in YAML â€” no code required.

<Mermaid chart={`graph LR
    INPUT["ğŸ• Input"]:::stage --> EVENT["ğŸ“„ Event"]:::stage
    EVENT --> OUTPUT["ğŸ“¤ Output"]:::stage
    classDef stage fill:#8282ef,color:#fff,stroke:#6b6bd4,stroke-width:2px`} />

<div className="not-prose grid grid-cols-1 sm:grid-cols-3 gap-3 my-6">
  <div className="rounded-xl border-2 border-[#8282ef]/30 bg-[#8282ef]/5 p-4 text-center">
    <div className="font-semibold mb-1">Input</div>
    <div className="text-sm text-fd-muted-foreground">Defines <strong>when</strong> events occur â€” schedules, timers, cron, or time patterns.</div>
  </div>
  <div className="rounded-xl border-2 border-[#8282ef]/30 bg-[#8282ef]/5 p-4 text-center">
    <div className="font-semibold mb-1">Event</div>
    <div className="text-sm text-fd-muted-foreground">Defines <strong>what</strong> events look like â€” Jinja2 templates, Python scripts, or log replay.</div>
  </div>
  <div className="rounded-xl border-2 border-[#8282ef]/30 bg-[#8282ef]/5 p-4 text-center">
    <div className="font-semibold mb-1">Output</div>
    <div className="text-sm text-fd-muted-foreground">Defines <strong>where</strong> events go â€” stdout, files, databases, or HTTP endpoints.</div>
  </div>
</div>

Swap any part independently: change the schedule without touching the template, or add a new output without modifying anything else.

---

## ğŸš€ Quick example

<Steps>
<Step>
### Create a template

Templates use Jinja2 syntax with built-in modules like `faker` for realistic data. Each render receives a `timestamp` variable.

```jinja title="events.jinja"
{{ timestamp }} INFO  user={{ module.faker.user_name() }} action=login ip={{ module.faker.ipv4() }}
```

</Step>
<Step>
### Create a generator config

Wire the three pipeline stages together â€” `cron` input firing every second, `template` event plugin, and `stdout` output.

```yaml title="generator.yml"
input:
  - cron:
      expression: "* * * * * *"
      count: 1

event:
  template:
    mode: all
    templates:
      - my_event:
          template: events.jinja

output:
  - stdout: {}
```

</Step>
<Step>
### Run the generator

```bash
eventum generate --path generator.yml --live-mode
```

Events start printing at one per second:

```
2025-06-15 12:00:01+00:00 INFO  user=jsmith action=login ip=192.168.44.12
2025-06-15 12:00:02+00:00 INFO  user=amiller action=login ip=10.0.128.55
2025-06-15 12:00:03+00:00 INFO  user=kwilson action=login ip=172.16.0.91
```

</Step>
</Steps>

<Callout type="info">
This example runs a single generator from the command line. To run multiple generators
with a server, API, and web UI, see the [`eventum run`](/docs/core/cli/eventum-run) command.
</Callout>

---

## ğŸ“– What's next

<Cards>
  <Card
    title="Installation"
    description="Install Eventum as a Python package, from source, or with Docker."
    href="/docs/core/introduction/installation"
  />
  <Card
    title="Features"
    description="Explore the full set of capabilities Eventum provides."
    href="/docs/core/introduction/features"
  />
  <Card
    title="Core concepts"
    description="Learn about generators, plugins, scheduling, and the event pipeline."
    href="/docs/core/concepts/generator"
  />
  <Card
    title="First run"
    description="Step-by-step guide to setting up your first project from scratch."
    href="/docs/core/introduction/first-run"
  />
</Cards>
