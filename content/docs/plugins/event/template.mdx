---
title: template
description: Event plugin that renders Jinja2 templates with Faker, Mimesis, random helpers, state management, and multiple picking modes.
---

Renders Jinja2 templates with a rich context — timestamps, data-generation modules, samples, and persistent state. This is the most commonly used event plugin and covers the vast majority of synthetic data generation scenarios.

For a conceptual walkthrough of template features, see [Producing events](/docs/core/concepts/producing).

## Common fields

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `mode` | string | — | Required. One of: `all`, `any`, `chance`, `spin`, `chain`, `fsm`. |
| `templates` | list of template configs | — | Required. At least one template. |
| `params` | mapping | `{}` | Extra parameters accessible in templates via `params`. |
| `samples` | mapping of [sample configs](#samples) | `{}` | Named datasets accessible in templates via `samples`. |

The `mode` field determines how templates are selected for each incoming timestamp.

---

## Template context

Inside a `.jinja` template, the following variables are available:

| Variable | Type | Description |
|----------|------|-------------|
| `timestamp` | `datetime` | Timezone-aware datetime of the current event. |
| `tags` | `tuple[str, ...]` | Tags from the input plugin that produced this timestamp. |
| `module` | module provider | Gateway to data-generation libraries and any Python module. See [Modules](#modules). |
| `params` | `dict` | User-defined constant parameters from the `params` config field. |
| `vars` | `dict` | Per-template variables from the `vars` config field. Each template entry can define its own `vars`, allowing the same `.jinja` file to be reused with different bindings. |
| `samples` | sample reader | Named datasets from the `samples` config field. See [Samples](#samples). |
| `locals` | state | Per-template state that persists across renders. See [State](#state). |
| `shared` | state | State shared across all templates in the same generator. See [State](#state). |
| `globals` | state | State shared across all generators, thread-safe. See [State](#state). |
| `subprocess` | subprocess runner | Execute shell commands. See [Subprocess](#subprocess). |

`timestamp` is a standard Python `datetime` object — all its methods work directly: `timestamp.isoformat()`, `timestamp.strftime('%Y-%m-%d')`, `timestamp.year`, `timestamp.hour`, etc.

---

## Modules

The `module` object provides access to three built-in data-generation libraries and acts as a gateway to any Python package installed in the environment. Access a module by name: `module.<name>`.

### `module.rand`

Built-in random utilities organized into namespaces. This is the most commonly used module for generating synthetic data.

#### Top-level functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `choice` | `(items) → T` | Return a random item from a sequence. |
| `choices` | `(items, n) → list[T]` | Return `n` random items with replacement. |
| `weighted_choice` | `(items, weights) → T` | Return a random item with weighted probability. Also accepts a dict: `({item: weight, ...})`. |
| `weighted_choices` | `(items, weights, n) → list[T]` | Return `n` items with weighted probability. Also accepts a dict: `({item: weight, ...}, n)`. |
| `shuffle` | `(items) → list \| str` | Shuffle elements. Returns a string if the input is a string. |
| `chance` | `(prob) → bool` | Return `True` with the given probability (0.0–1.0). |

```jinja
{%- set method = module.rand.choice(["GET", "POST", "PUT", "DELETE"]) -%}

{# Dict form — keys are items, values are weights #}
{%- set status = module.rand.weighted_choice({200: 80, 301: 5, 404: 10, 500: 5}) -%}

{# Two-sequence form — also supported #}
{%- set status = module.rand.weighted_choice([200, 301, 404, 500], [80, 5, 10, 5]) -%}

{% if module.rand.chance(0.05) %}RARE EVENT{% endif %}
```

#### `rand.number`

| Function | Signature | Description |
|----------|-----------|-------------|
| `integer` | `(a, b) → int` | Random integer in \[a, b\] inclusive. |
| `floating` | `(a, b) → float` | Random float in \[a, b\]. |
| `gauss` | `(mu, sigma) → float` | Random float from a Gaussian (normal) distribution. |
| `lognormal` | `(mu, sigma) → float` | Random float from a log-normal distribution (always positive, right-skewed). |
| `exponential` | `(lambd) → float` | Random float from an exponential distribution. `lambd` is the rate (1/mean). |
| `pareto` | `(alpha, xmin=1.0) → float` | Random float from a Pareto distribution (heavy-tailed, values ≥ `xmin`). |
| `triangular` | `(low, high, mode) → float` | Random float from a triangular distribution in \[`low`, `high`\] peaking at `mode`. |
| `clamp` | `(value, min, max) → float` | Clamp `value` to the range \[`min`, `max`\]. |

```jinja
{%- set port = module.rand.number.integer(1024, 65535) -%}
{%- set latency = module.rand.number.floating(0.1, 2.5) -%}
{%- set score = module.rand.number.gauss(50, 10) -%}

{# Statistical distributions #}
{%- set duration = module.rand.number.lognormal(3.0, 1.0) -%}
{%- set wait_time = module.rand.number.exponential(0.5) -%}
{%- set file_size = module.rand.number.pareto(1.5, xmin=100.0) -%}
{%- set temperature = module.rand.number.triangular(15.0, 35.0, 22.0) -%}

{# Combine a distribution with clamp to bound the result #}
{%- set bytes_sent = module.rand.number.clamp(module.rand.number.gauss(5000, 2000), 0, 15000) -%}
```

#### `rand.string`

| Function | Signature | Description |
|----------|-----------|-------------|
| `letters_lowercase` | `(size) → str` | Random lowercase ASCII letters. |
| `letters_uppercase` | `(size) → str` | Random uppercase ASCII letters. |
| `letters` | `(size) → str` | Random mixed-case ASCII letters. |
| `digits` | `(size) → str` | Random digit characters. |
| `punctuation` | `(size) → str` | Random ASCII punctuation characters. |
| `hex` | `(size) → str` | Random hex characters (0–9, a–f). |

```jinja
{%- set token = module.rand.string.hex(32) -%}
{%- set code = module.rand.string.letters_uppercase(6) -%}
```

#### `rand.network`

| Function | Signature | Description |
|----------|-----------|-------------|
| `ip_v4` | `() → str` | Random IPv4 address (any range). |
| `ip_v4_public` | `() → str` | Random public IPv4 (excludes private and reserved ranges). |
| `ip_v4_private_a` | `() → str` | Random Class A private IPv4 (10.0.0.0/8). |
| `ip_v4_private_b` | `() → str` | Random Class B private IPv4 (172.16.0.0/12). |
| `ip_v4_private_c` | `() → str` | Random Class C private IPv4 (192.168.0.0/16). |
| `mac` | `() → str` | Random MAC address (colon-separated, e.g. `a4:3b:00:ff:12:9e`). |

```jinja
{%- set src_ip = module.rand.network.ip_v4_public() -%}
{%- set dst_ip = module.rand.network.ip_v4_private_c() -%}
{%- set mac_addr = module.rand.network.mac() -%}
```

#### `rand.crypto`

| Function | Signature | Description |
|----------|-----------|-------------|
| `uuid4` | `() → str` | Random UUID v4. |
| `md5` | `() → str` | Random 32-character hex string (MD5-length). |
| `sha256` | `() → str` | Random 64-character hex string (SHA-256-length). |

```jinja
{%- set request_id = module.rand.crypto.uuid4() -%}
{%- set checksum = module.rand.crypto.sha256() -%}
```

#### `rand.datetime`

| Function | Signature | Description |
|----------|-----------|-------------|
| `timestamp` | `(start, end) → datetime` | Random timestamp in range \[start, end\]. Both arguments are `datetime` objects. |

#### Combined example

```jinja
{%- set src_ip = module.rand.network.ip_v4_public() -%}
{%- set method = module.rand.weighted_choice(["GET", "POST", "PUT"], [70, 20, 10]) -%}
{%- set status = module.rand.weighted_choice([200, 301, 404, 500], [80, 5, 10, 5]) -%}
{%- set request_id = module.rand.crypto.uuid4() -%}
{%- set bytes_sent = module.rand.number.integer(200, 15000) -%}
{{ timestamp.isoformat() }} {{ src_ip }} {{ method }} /api/resource {{ status }} {{ bytes_sent }} {{ request_id }}
```

### `module.faker`

The [Faker](https://faker.readthedocs.io/) library for generating realistic fake data. Access a Faker instance by locale:

```jinja
{{ module.faker.locale['en_US'].name() }}            {# "John Smith" #}
{{ module.faker.locale['en_US'].email() }}            {# "john.smith@example.com" #}
{{ module.faker.locale['en_US'].ipv4() }}             {# "192.168.1.100" #}
{{ module.faker.locale['en_US'].user_agent() }}       {# "Mozilla/5.0 ..." #}
{{ module.faker.locale['de_DE'].city() }}             {# "Berlin" #}
{{ module.faker.locale['ja_JP'].name() }}             {# "山田 太郎" #}
```

Locale instances are created once and cached. Faker supports [hundreds of providers](https://faker.readthedocs.io/en/master/providers.html) — names, addresses, phone numbers, credit cards, companies, dates, user agents, and more.

<Callout>
In Jinja2, both dot notation (`module.faker.locale.en_US`) and bracket notation (`module.faker.locale['en_US']`) work. Bracket notation is recommended for locale codes with special characters.
</Callout>

### `module.mimesis`

The [Mimesis](https://mimesis.name/) library for high-performance data generation. It provides four access paths:

| Access path | Returns | Description |
|-------------|---------|-------------|
| `module.mimesis.locale['en']` | `Generic` | Full Mimesis provider for a locale. |
| `module.mimesis.spec['usa']` | country-specific provider | Country-specific data (SSN, tax ID, etc.). |
| `module.mimesis.enums` | module | Mimesis enums (`Gender`, `FileType`, `TLDType`, etc.). |
| `module.mimesis.random` | module | Mimesis random utilities. |

```jinja
{{ module.mimesis.locale['en'].person.full_name() }}        {# "John Doe" #}
{{ module.mimesis.locale['en'].internet.ip_v4() }}          {# "10.0.1.42" #}
{{ module.mimesis.locale['en'].address.city() }}            {# "San Francisco" #}
{{ module.mimesis.locale['ru'].person.full_name() }}        {# "Иванов Иван" #}
{{ module.mimesis.spec['usa'].ssn() }}                      {# "123-45-6789" #}
```

Available `spec` keys: `brazil`, `denmark`, `italy`, `netherlands`, `poland`, `russia`, `ukraine`, `usa`.

### Any Python module

If the name isn't one of the three built-ins (`rand`, `faker`, `mimesis`), the `module` object imports it from the Python standard library or any package installed in the environment:

```jinja
{# Standard library #}
{{ module.json.dumps({"event": "test"}) }}
{{ module.math.ceil(3.14) }}
{{ module.hashlib.sha256(b"data").hexdigest() }}
{{ module.base64.b64encode(b"hello").decode() }}
{{ module.datetime.timedelta(seconds=30) }}
```

Modules are imported once and cached for subsequent access. If a module is not found, a `KeyError` is raised.

---

## State

Templates can store and retrieve values that persist across renders. State is organized into three scopes:

| Scope | Variable | Visibility | Thread safety | Typical use |
|-------|----------|------------|---------------|-------------|
| Local | `locals` | Current template only | Single-threaded | Per-template counters, accumulators |
| Shared | `shared` | All templates in one generator | Single-threaded | Cross-template coordination, session tracking |
| Global | `globals` | All generators in the application | Thread-safe (RLock) | Global counters, inter-generator data |

### State API

All three scopes provide the same methods:

| Method | Signature | Description |
|--------|-----------|-------------|
| `get` | `(key, default=None) → Any` | Get a value. Returns `default` if the key doesn't exist. |
| `set` | `(key, value) → None` | Set a value. |
| `update` | `(mapping) → None` | Set multiple values at once from a dict. |
| `clear` | `() → None` | Remove all values. |
| `as_dict` | `() → dict` | Get a shallow copy of the entire state. |
| `[key]` | bracket access | Same as `get(key)`. |

The `globals` scope has two additional methods for manual locking:

| Method | Description |
|--------|-------------|
| `acquire()` | Acquire the state lock. |
| `release()` | Release the state lock. |

<Callout type="warn">
Individual `globals` operations (`get`, `set`, etc.) are already thread-safe. Use `acquire()` / `release()` only when you need multiple operations to execute atomically — for example, reading a counter and incrementing it without another generator modifying it in between.
</Callout>

### Examples

**Per-template counter** with `locals`:

```jinja
{%- do locals.set('n', locals.get('n', 0) + 1) -%}
Event #{{ locals.get('n') }} at {{ timestamp.isoformat() }}
```

**Monotonic record ID** with `shared` — a common pattern where all templates in a generator share a single incrementing counter:

```jinja
{%- set record_id = shared.get('record_id', 1) -%}
... use record_id in the event body ...
{%- do shared.set('record_id', record_id + 1) -%}
```

**Atomic compound operation** with `globals`:

```jinja
{%- do globals.acquire() -%}
{%- set total = globals.get('total', 0) -%}
{%- do globals.set('total', total + 1) -%}
{%- do globals.release() -%}
```

---

## Subprocess

The `subprocess` variable lets you execute shell commands from templates.

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `command` | string | — | Shell command to execute. |
| `cwd` | string | `None` | Working directory. |
| `env` | mapping | `None` | Environment variables. |
| `timeout` | float | `None` | Timeout in seconds. |

The `run` method returns a result object with three fields:

| Field | Type | Description |
|-------|------|-------------|
| `stdout` | string | Standard output (decoded as UTF-8). |
| `stderr` | string | Standard error (decoded as UTF-8). |
| `exit_code` | int | Process exit code. |

```jinja
{%- set result = subprocess.run('hostname', timeout=5.0) -%}
{{ result.stdout | trim }}
```

<Callout type="warn">
Subprocess calls run synchronously and block event production. Use short timeouts to avoid stalling the pipeline.
</Callout>

---

## Jinja2 extensions

The template environment loads two Jinja2 extensions automatically:

| Extension | What it enables | Example |
|-----------|-----------------|---------|
| `jinja2.ext.do` | Expression statements via `{% do ... %}` — call methods that return nothing without producing output. | `{% do shared.set('count', 0) %}` |
| `jinja2.ext.loopcontrols` | `{% break %}` and `{% continue %}` inside `{% for %}` loops. | `{% for u in users %}{% if u.skip %}{% continue %}{% endif %}{{ u.name }}{% endfor %}` |

The `do` extension is essential for state management — without it, calling `shared.set(...)` (which returns `None`) would require workarounds like `{% set _ = shared.set(...) %}`.

---

## Modes

### all

Every template is rendered for every timestamp. Produces N events per timestamp, where N is the number of templates.

```yaml
event:
  template:
    mode: all
    templates:
      - access_log:
          template: templates/access.jinja
      - error_log:
          template: templates/error.jinja
```

### any

A single template is chosen at random (uniform distribution) for each timestamp.

```yaml
event:
  template:
    mode: any
    templates:
      - success:
          template: templates/success.jinja
      - error:
          template: templates/error.jinja
```

### chance

A single template is chosen at random with **weighted probability**. Each template has a `chance` value — the higher the value relative to others, the more likely it is to be selected.

| Extra parameter | Type | Constraints | Description |
|-----------------|------|-------------|-------------|
| `chance` | float | Required. > 0 | Relative probability weight. |

```yaml
event:
  template:
    mode: chance
    templates:
      - success:
          template: templates/success.jinja
          chance: 90
      - error:
          template: templates/error.jinja
          chance: 10
```

### spin

Templates are rendered in round-robin order. The first timestamp uses the first template, the second uses the second, and so on, cycling back to the first after the last.

```yaml
event:
  template:
    mode: spin
    templates:
      - request:
          template: templates/request.jinja
      - response:
          template: templates/response.jinja
```

### chain

Templates are rendered in a fixed order defined by the `chain` list. All templates in the chain are rendered for every timestamp, in the specified order.

| Extra parameter | Type | Constraints | Description |
|-----------------|------|-------------|-------------|
| `chain` | list of strings | Required. At least one alias. | Ordered list of template aliases to render. |

```yaml
event:
  template:
    mode: chain
    chain: [login, browse, checkout, logout]
    templates:
      - login:
          template: templates/login.jinja
      - browse:
          template: templates/browse.jinja
      - checkout:
          template: templates/checkout.jinja
      - logout:
          template: templates/logout.jinja
```

### fsm

Templates represent states in a **finite state machine**. After each timestamp, the machine evaluates transition conditions to decide the next state. This enables stateful event sequences like user sessions or protocol flows.

**How it works:**
1. The machine starts at the template marked `initial: true`.
2. That template is rendered, producing an event. During rendering, the template can modify state variables (`locals`, `shared`, `globals`).
3. After rendering, transitions are evaluated **in order** — the first transition whose `when` condition is `true` fires.
4. The machine moves to the state named in the `to` field.
5. On the next timestamp, the new current template is rendered and the cycle repeats.
6. If no transition matches, the machine stays in the current state.

| Extra parameter | Type | Default | Constraints | Description |
|-----------------|------|---------|-------------|-------------|
| `initial` | boolean | `false` | Exactly one template must be `true`. | Marks the starting state. |
| `transitions` | list of [transition configs](#fsm-transitions) | `[]` | — | Possible transitions from this state. |

```yaml
event:
  template:
    mode: fsm
    templates:
      - idle:
          template: templates/idle.jinja
          initial: true
          transitions:
            - to: active
              when:
                gt:
                  shared.request_count: 0
      - active:
          template: templates/active.jinja
          transitions:
            - to: idle
              when:
                eq:
                  shared.request_count: 0
```

---

## Template entry

For `all`, `any`, `spin`, and `chain` modes:

| Parameter | Type | Default | Constraints | Description |
|-----------|------|---------|-------------|-------------|
| `template` | path | — | Required. Must end with `.jinja`. | Path to the Jinja2 template file. |
| `vars` | mapping | `{}` | — | Per-template variables accessible in the template via `vars`. Allows the same template file to be reused with different bindings. |

For `chance` mode, add the `chance` field. For `fsm` mode, add `initial` and `transitions`.

---

## FSM transitions

Each transition defines a target state and a condition:

| Parameter | Type | Description |
|-----------|------|-------------|
| `to` | string | Target template alias. |
| `when` | [condition](#fsm-conditions) | Condition that must evaluate to `true` for the transition to fire. |

Transitions are evaluated **in order** — the first matching transition wins. If no transition matches, the machine stays in the current state. Use `always` as a fallback at the end of a transitions list.

```yaml
transitions:
  # Evaluated first: go to "error" if too many failures
  - to: error
    when:
      gt:
        shared.fail_count: 10
  # Evaluated second: go to "done" if counter hit zero
  - to: done
    when:
      eq:
        shared.remaining: 0
  # Fallback: stay in "active" otherwise
  - to: active
    when:
      always:
```

## FSM conditions

Conditions inspect template state variables or event metadata. State is organized into three scopes, and field names follow the pattern `<scope>.<field>`:

| Scope | Pattern | Description |
|-------|---------|-------------|
| `locals` | `locals.counter` | State local to the current template. Each template has its own locals. |
| `shared` | `shared.status` | Shared across all templates within the same generator. |
| `globals` | `globals.session_id` | Global state shared across all generators. |

Templates set state values during rendering (e.g., `{% do shared.set("counter", shared.counter + 1) %}`), and transitions read those values to decide the next state.

### Comparison checks

Each takes a mapping of `<state_field>: <value>`:

| Condition | Description | Example |
|-----------|-------------|---------|
| `eq` | Field equals value | `eq: { shared.status: "ready" }` |
| `gt` | Field greater than value | `gt: { locals.retries: 3 }` |
| `ge` | Field greater than or equal to value | `ge: { shared.score: 100 }` |
| `lt` | Field less than value | `lt: { locals.ttl: 0 }` |
| `le` | Field less than or equal to value | `le: { shared.attempts: 5 }` |
| `matches` | Field matches regex pattern | `matches: { shared.path: "^/api/.*" }` |

```yaml
# Transition when a counter exceeds a threshold
- to: overloaded
  when:
    gt:
      shared.request_count: 1000

# Transition when status matches a pattern
- to: api_handler
  when:
    matches:
      shared.path: "^/api/v[0-9]+/"
```

### Length checks

Check the length of a sequence field:

| Condition | Description | Example |
|-----------|-------------|---------|
| `len_eq` | Length equals value | `len_eq: { shared.queue: 0 }` |
| `len_gt` | Length greater than value | `len_gt: { shared.items: 10 }` |
| `len_ge` | Length greater or equal | `len_ge: { shared.batch: 50 }` |
| `len_lt` | Length less than value | `len_lt: { shared.buffer: 100 }` |
| `len_le` | Length less or equal | `len_le: { shared.errors: 3 }` |

```yaml
# Transition when a queue is full
- to: flush
  when:
    len_ge:
      shared.event_buffer: 100

# Transition when all items are processed
- to: complete
  when:
    len_eq:
      shared.pending_items: 0
```

### Membership checks

| Condition | Description | Example |
|-----------|-------------|---------|
| `contains` | Sequence field contains value | `contains: { shared.seen_codes: 500 }` |
| `in` | Value is in sequence field | `in: { shared.status: ["error", "fatal"] }` |

```yaml
# Transition if a specific error code was encountered
- to: handle_server_error
  when:
    contains:
      shared.error_codes: 500

# Transition if current status is one of several values
- to: retry
  when:
    in:
      shared.status: ["timeout", "rate_limited", "unavailable"]
```

### Timestamp checks

Evaluate the current event timestamp against specified time components. Any subset of components can be provided — unspecified components are ignored.

| Condition | Description |
|-----------|-------------|
| `before` | Current timestamp is before the specified time. |
| `after` | Current timestamp is at or after the specified time. |

Available components: `year`, `month`, `day`, `hour`, `minute`, `second`, `microsecond`.

```yaml
# Business hours: different behavior before and after 9 AM
- to: peak_traffic
  when:
    after:
      hour: 9
      minute: 0

# Switch to end-of-year mode in December
- to: year_end_processing
  when:
    after:
      month: 12
      day: 1
```

### State and tag checks

| Condition | Description | Example |
|-----------|-------------|---------|
| `defined` | State field exists | `defined: locals.user_id` |
| `has_tags` | Event has tag(s) | `has_tags: critical` or `has_tags: [urgent, high]` |
| `always` | Always true (unconditional) | `always:` |
| `never` | Always false | `never:` |

```yaml
# Transition only if a field has been set during rendering
- to: authenticated
  when:
    defined: shared.auth_token

# Transition based on event tags
- to: alert
  when:
    has_tags: [critical, security]

# Unconditional fallback (always goes to this state)
- to: default_state
  when:
    always:
```

### Logic operators

Combine or negate conditions:

| Operator | Description |
|----------|-------------|
| `or` | List of conditions (at least 2). True if **any** is true. |
| `and` | List of conditions (at least 2). True if **all** are true. |
| `not` | Single condition. Inverts the result. |

```yaml
# AND: both conditions must be true
- to: critical_alert
  when:
    and:
      - gt:
          shared.error_count: 5
      - has_tags: critical

# OR: either condition triggers the transition
- to: throttle
  when:
    or:
      - gt:
          shared.request_count: 10000
      - gt:
          shared.error_rate: 0.5

# NOT: transition when the field is NOT in the expected set
- to: unknown_method
  when:
    not:
      in:
        shared.method: ["GET", "POST", "PUT", "DELETE"]

# Nested: complex logic
- to: escalate
  when:
    and:
      - gt:
          shared.fail_count: 3
      - or:
          - has_tags: production
          - gt:
              shared.severity: 8
```

---

## FSM examples

### User session flow

A user goes through login, browsing, and logout. The session tracks page views in shared state and transitions based on accumulated activity.

```yaml
event:
  template:
    mode: fsm
    templates:
      - login:
          template: templates/login.jinja
          initial: true
          transitions:
            - to: browse
              when:
                always:

      - browse:
          template: templates/browse.jinja
          transitions:
            # After 10+ page views, user proceeds to checkout
            - to: checkout
              when:
                ge:
                  shared.page_views: 10
            # Small chance of early logout (handled in template via random)
            - to: logout
              when:
                eq:
                  shared.should_leave: true
            # Otherwise keep browsing (stay in current state)

      - checkout:
          template: templates/checkout.jinja
          transitions:
            - to: logout
              when:
                always:

      - logout:
          template: templates/logout.jinja
          transitions:
            # Start a new session
            - to: login
              when:
                always:
```

In `templates/browse.jinja`, the template updates state:
```
{%- do shared.set("page_views", shared.get("page_views", 0) + 1) -%}
{%- do shared.set("should_leave", random.random() < 0.05) -%}
{{ timestamp }} GET /page/{{ random.randint(1, 100) }} 200
```

### HTTP request-response with errors

Model a client that sends requests and may get errors, retries, and eventually either succeeds or gives up.

```yaml
event:
  template:
    mode: fsm
    templates:
      - send_request:
          template: templates/request.jinja
          initial: true
          transitions:
            - to: handle_error
              when:
                gt:
                  shared.status_code: 399
            - to: success
              when:
                le:
                  shared.status_code: 399

      - handle_error:
          template: templates/error.jinja
          transitions:
            # Give up after 3 retries
            - to: give_up
              when:
                ge:
                  shared.retries: 3
            # Retry
            - to: send_request
              when:
                always:

      - success:
          template: templates/success.jinja
          transitions:
            - to: send_request
              when:
                always:

      - give_up:
          template: templates/give_up.jinja
          transitions:
            # Reset and start fresh
            - to: send_request
              when:
                always:
```

### Time-of-day traffic patterns

Use timestamp conditions to switch between traffic patterns depending on the hour.

```yaml
event:
  template:
    mode: fsm
    templates:
      - night_traffic:
          template: templates/night.jinja
          initial: true
          transitions:
            - to: morning_ramp
              when:
                after:
                  hour: 6

      - morning_ramp:
          template: templates/morning.jinja
          transitions:
            - to: peak_traffic
              when:
                after:
                  hour: 9
            - to: night_traffic
              when:
                before:
                  hour: 6

      - peak_traffic:
          template: templates/peak.jinja
          transitions:
            - to: evening_wind_down
              when:
                after:
                  hour: 17

      - evening_wind_down:
          template: templates/evening.jinja
          transitions:
            - to: night_traffic
              when:
                after:
                  hour: 22
```

### Authentication flow with state checks

Model a system where login creates a token, authenticated requests use it, and the token can expire.

```yaml
event:
  template:
    mode: fsm
    templates:
      - unauthenticated:
          template: templates/login_attempt.jinja
          initial: true
          transitions:
            # Template sets shared.auth_token on successful login
            - to: authenticated
              when:
                defined: shared.auth_token
            # Stay unauthenticated if login fails

      - authenticated:
          template: templates/api_call.jinja
          transitions:
            # Token expired (template increments request_count)
            - to: unauthenticated
              when:
                gt:
                  shared.request_count: 50
            # Error threshold reached
            - to: locked_out
              when:
                and:
                  - gt:
                      shared.consecutive_errors: 5
                  - has_tags: auth_failure

      - locked_out:
          template: templates/locked.jinja
          transitions:
            # Cool down, then allow retry
            - to: unauthenticated
              when:
                gt:
                  shared.cooldown_ticks: 10
```

### Multi-stage pipeline with queue tracking

Track items flowing through processing stages using length checks.

```yaml
event:
  template:
    mode: fsm
    templates:
      - ingesting:
          template: templates/ingest.jinja
          initial: true
          transitions:
            # When batch is full, move to processing
            - to: processing
              when:
                len_ge:
                  shared.batch: 100

      - processing:
          template: templates/process.jinja
          transitions:
            # Processing error: some items matched error pattern
            - to: error_handling
              when:
                contains:
                  shared.failed_ids: "FATAL"
            # All processed
            - to: flushing
              when:
                len_eq:
                  shared.batch: 0

      - error_handling:
          template: templates/error_handler.jinja
          transitions:
            - to: processing
              when:
                not:
                  contains:
                    shared.failed_ids: "FATAL"
            - to: flushing
              when:
                always:

      - flushing:
          template: templates/flush.jinja
          transitions:
            - to: ingesting
              when:
                always:
```

---

## Samples

Named datasets loaded once at startup and accessible in templates via `samples.<name>`. Three sample types are available:

### items

Inline list of values:

| Parameter | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| `type` | string | Must be `"items"`. | Sample type discriminator. |
| `source` | list | At least one item. | Inline list of values. |

```yaml
samples:
  status_codes:
    type: items
    source: [200, 201, 301, 404, 500]
```

### csv

Load from a CSV file:

| Parameter | Type | Default | Constraints | Description |
|-----------|------|---------|-------------|-------------|
| `type` | string | — | Must be `"csv"`. | Sample type discriminator. |
| `source` | path | — | Must end with `.csv`. | Path to the CSV file. |
| `header` | boolean | `false` | — | Whether the first row is a header. |
| `delimiter` | string | `","` | Non-empty. | Column delimiter. |
| `quotechar` | string | `'"'` | Single character. | Character used to quote fields containing the delimiter or newlines ([RFC 4180](https://www.rfc-editor.org/rfc/rfc4180)). |

```yaml
samples:
  users:
    type: csv
    source: samples/users.csv
    header: true
```

### json

Load from a JSON file (array of objects with consistent keys):

| Parameter | Type | Constraints | Description |
|-----------|------|-------------|-------------|
| `type` | string | Must be `"json"`. | Sample type discriminator. |
| `source` | path | Must end with `.json`. | Path to the JSON file. |

```yaml
samples:
  endpoints:
    type: json
    source: samples/endpoints.json
```

<Callout>
All objects in a JSON sample must have the **same set of keys**. If keys differ between objects, the sample will fail to load with an error.
</Callout>

### Accessing sample rows

Each row in a sample is a tuple-like object. You can pick a random row and access its fields:

```jinja
{%- set user = samples.users | random -%}
```

**Named access** — CSV samples with `header: true` and JSON samples expose fields by name, matching CSV column headers or JSON object keys:

```jinja
{%- set user = samples.users | random -%}
{{ user.name }}           {# "John" #}
{{ user.email }}          {# "john@example.com" #}
```

This works with Jinja2 filters like `selectattr`:

```jinja
{%- set admins = samples.users | selectattr("role", "equalto", "admin") | list -%}
```

**Index access** — all sample types (including `items` and CSV without headers) support positional index access:

```jinja
{{ user[0] }}             {# first field #}
{{ user[1] }}             {# second field #}
```

Both access styles work on the same row — named access is available whenever headers or keys are present, index access always works.

### Picking sample rows

Each sample provides methods for random row selection — both uniform and weighted.

#### Uniform picking

Use `pick()` to select a single random row, or `pick_n(n)` to select multiple:

```jinja
{%- set user = samples.users.pick() -%}
{{ user.name }}

{%- set five_users = samples.users.pick_n(5) -%}
{%- for u in five_users -%}
  {{ u.name }}
{%- endfor -%}
```

| Method | Signature | Description |
|--------|-----------|-------------|
| `pick` | `() → Row` | Pick a single random row (uniform distribution). |
| `pick_n` | `(n: int) → list[Row]` | Pick `n` random rows with replacement. |

<Callout>
`pick()` is equivalent to `| random` but is also available as a method for consistency with the weighted API below.
</Callout>

#### Weighted picking

If your sample includes a numeric column for weights, you can pick rows with probability proportional to those weights:

```csv title="samples/services.csv"
name,port,protocol,weight
HTTP,80,tcp,50
HTTPS,443,tcp,30
SSH,22,tcp,10
DNS,53,udp,10
```

```jinja
{%- set service = samples.services.weighted_pick('weight') -%}
{{ service.name }}:{{ service.port }}

{%- set batch = samples.services.weighted_pick_n('weight', 10) -%}
```

| Method | Signature | Description |
|--------|-----------|-------------|
| `weighted_pick` | `(weight: str) → Row` | Pick a single random row with probability proportional to the named weight column. |
| `weighted_pick_n` | `(weight: str, n: int) → list[Row]` | Pick `n` random rows with replacement, weighted by the named column. |

<Callout>
The weight column must contain numeric values (integers or floats). Negative values and all-zero weights will produce an error. The weight column remains part of the returned row — you can simply ignore it in your template.
</Callout>

<Callout>
Weights are extracted and cached on the first call. Repeated calls to `weighted_pick` with the same column are efficient even at high throughput.
</Callout>

---

## Examples

### Parameterized template reuse with vars

Multiple template entries can point to the **same** `.jinja` file with different per-template variables. This eliminates duplication when events differ only by a few constants — such as protocol variants:

```yaml title="generator.yml"
event:
  template:
    mode: chance
    params:
      hostname: fw-01
    templates:
      - tcp_built:
          template: templates/connection-built.json.jinja
          chance: 220
          vars:
            protocol: tcp
            iana_number: "6"
      - udp_built:
          template: templates/connection-built.json.jinja
          chance: 75
          vars:
            protocol: udp
            iana_number: "17"
      - icmp_built:
          template: templates/connection-built.json.jinja
          chance: 15
          vars:
            protocol: icmp
            iana_number: "1"
```

```jinja title="templates/connection-built.json.jinja"
{%- set src_ip = module.rand.network.ip_v4_private_c() -%}
{%- set dst_ip = module.rand.network.ip_v4_public() -%}
{%- set src_port = module.rand.number.integer(1024, 65535) -%}
{%- set dst_port = module.rand.number.integer(1, 1023) -%}
{"timestamp": "{{ timestamp.isoformat() }}", "hostname": "{{ params.hostname }}", "protocol": "{{ vars.protocol }}", "iana_number": {{ vars.iana_number }}, "src": "{{ src_ip }}:{{ src_port }}", "dst": "{{ dst_ip }}:{{ dst_port }}"}
```

One template file, three config entries — instead of three nearly identical template files.

### Access log with modules, params, and samples

A generator that produces HTTP access log lines using random utilities, user-defined parameters, and sample data:

```csv title="samples/users.csv"
name,email,role
John,john@example.com,admin
Jane,jane@example.com,user
```

```yaml title="generator.yml"
event:
  template:
    mode: chance
    params:
      app_name: my-service
      server_port: 8080
    samples:
      users:
        type: csv
        source: samples/users.csv
        header: true
      paths:
        type: items
        source: ["/api/users", "/api/orders", "/api/products", "/health"]
    templates:
      - access:
          template: templates/access.jinja
          chance: 95
      - error:
          template: templates/error.jinja
          chance: 5
```

```jinja title="templates/access.jinja"
{%- set user = samples.users | random -%}
{%- set path = module.rand.choice(samples.paths) -%}
{%- set status = module.rand.weighted_choice([200, 301, 404], [85, 5, 10]) -%}
{%- set bytes_sent = module.rand.number.integer(200, 15000) -%}
{%- set request_id = module.rand.crypto.uuid4() -%}
{{ timestamp.isoformat() }} [{{ params.app_name }}] {{ user.name }} ({{ user.email }}) GET {{ path }} {{ status }} {{ bytes_sent }} {{ request_id }}
```

### Monotonic counter with shared state

All templates in a generator share a single incrementing counter via `shared`. The counter persists across renders regardless of which template is picked:

```yaml title="generator.yml"
event:
  template:
    mode: all
    templates:
      - event_a:
          template: templates/event_a.jinja
      - event_b:
          template: templates/event_b.jinja
```

```jinja title="templates/event_a.jinja"
{%- set id = shared.get('seq', 1) -%}
{%- do shared.set('seq', id + 1) -%}
{"id": {{ id }}, "type": "A", "timestamp": "{{ timestamp.isoformat() }}"}
```

```jinja title="templates/event_b.jinja"
{%- set id = shared.get('seq', 1) -%}
{%- do shared.set('seq', id + 1) -%}
{"id": {{ id }}, "type": "B", "timestamp": "{{ timestamp.isoformat() }}"}
```

Since both templates use `shared`, the sequence is global to the generator. If `event_a` renders first and gets `id=1`, then `event_b` gets `id=2`.

### Cross-template correlation

Login events store session data in `shared` state that logout events consume — a common pattern for generating correlated event pairs:

```jinja title="templates/login.jinja"
{%- set session_id = module.rand.crypto.uuid4() -%}
{%- set user = samples.users | random -%}
{%- set sessions = shared.get('sessions', []) -%}
{%- do sessions.append({"id": session_id, "user": user.name}) -%}
{%- do shared.set('sessions', sessions) -%}
{{ timestamp.isoformat() }} LOGIN user={{ user.name }} session={{ session_id }}
```

```jinja title="templates/logout.jinja"
{%- set sessions = shared.get('sessions', []) -%}
{%- if sessions -%}
  {%- set session = sessions.pop(0) -%}
  {%- do shared.set('sessions', sessions) -%}
{{ timestamp.isoformat() }} LOGOUT user={{ session.user }} session={{ session.id }}
{%- else -%}
{{ timestamp.isoformat() }} LOGOUT user=anonymous session=none
{%- endif -%}
```

### Filtering sample data

Use Jinja2's `selectattr` filter to pick rows from samples that match specific criteria:

```jinja
{%- set admin_users = samples.users | selectattr("role", "equalto", "admin") | list -%}
{%- set user = admin_users | random -%}
{{ timestamp.isoformat() }} ADMIN_ACTION user={{ user.name }} action=config_change
```

You can also filter sample data in loops:

```jinja
{%- set category_urls = [] -%}
{%- for u in samples.urls if u.category == "api" -%}
  {%- do category_urls.append(u) -%}
{%- endfor -%}
{%- set url = category_urls | random -%}
```
